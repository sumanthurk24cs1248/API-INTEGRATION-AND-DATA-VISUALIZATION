import os
import json
import time
import random
import sqlite3
import threading
from flask import Flask, jsonify, render_template_string
import paho.mqtt.client as mqtt

# ========================= CONFIG =========================
MQTT_BROKER = "test.mosquitto.org"
MQTT_PORT = 1883
TOPIC = "smartwaste/bin1"
DB_FILE = "smartwaste.db"

# ==========================================================

# Create SQLite database if not exists
def init_db():
    if not os.path.exists(DB_FILE):
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        c.execute("""
            CREATE TABLE readings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bin_id TEXT,
                fill_level REAL,
                temp REAL,
                ts INTEGER
            )
        """)
        conn.commit()
        conn.close()
        print("Database created.")
    else:
        print("Database already exists.")

# ==========================================================
# MQTT SUBSCRIBER (BACKEND)
# ==========================================================
def insert_reading(bin_id, fill_level, temp, ts):
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute("INSERT INTO readings (bin_id, fill_level, temp, ts) VALUES (?, ?, ?, ?)",
              (bin_id, fill_level, temp, ts))
    conn.commit()
    conn.close()

def fetch_latest(limit=20):
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    c = conn.cursor()
    c.execute("SELECT * FROM readings ORDER BY ts DESC LIMIT ?", (limit,))
    rows = c.fetchall()
    conn.close()
    return [dict(r) for r in rows]

def on_connect(client, userdata, flags, rc):
    print("Connected to MQTT broker with rc:", rc)
    client.subscribe(TOPIC)

def on_message(client, userdata, msg):
    try:
        payload = msg.payload.decode("utf-8")
        data = json.loads(payload)
        bin_id = msg.topic.split("/")[-1]
        fill = float(data.get("fill_level", 0))
        temp = float(data.get("temp", 0))
        ts = int(data.get("ts", time.time()))
        print(f"Received from {bin_id}: fill={fill}%, temp={temp}°C")
        insert_reading(bin_id, fill, temp, ts)
    except Exception as e:
        print("Error handling message:", e)

def start_mqtt_backend():
    client = mqtt.Client("backend_collector")
    client.on_connect = on_connect
    client.on_message = on_message
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    client.loop_forever()

# ==========================================================
# SENSOR SIMULATOR (DEVICE)
# ==========================================================
def start_device_simulator():
    client = mqtt.Client("bin_simulator")
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    client.loop_start()
    try:
        while True:
            fill = round(random.uniform(10, 100), 1)
            temp = round(random.uniform(18, 40), 1)
            payload = json.dumps({
                "fill_level": fill,
                "temp": temp,
                "ts": int(time.time())
            })
            client.publish(TOPIC, payload)
            print("Published:", payload)
            time.sleep(8)
    except KeyboardInterrupt:
        pass
    finally:
        client.loop_stop()
        client.disconnect()

# ==========================================================
# FLASK DASHBOARD
# ==========================================================
app = Flask(__name__)

HTML_TEMPLATE = """
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Smart Waste Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1 { color: #004d99; }
    .bin-card { display:inline-block; border:1px solid #ccc; padding:12px; margin:8px; border-radius:8px; width:240px; }
    .high { background:#ffdddd; }
    .ok { background:#e6ffe6; }
  </style>
</head>
<body>
  <h1>Smart Waste Management Dashboard</h1>
  <div id="bins"></div>
  <h2>Fill Level History</h2>
  <canvas id="chart" width="800" height="300"></canvas>

  <script>
    async function fetchData() {
      const res = await fetch('/api/latest');
      const data = await res.json();
      document.getElementById('bins').innerHTML = '';
      let labels = [], fills = [], temps = [];
      data.reverse().forEach(r => {
        const cls = r.fill_level >= 85 ? 'high' : 'ok';
        const card = `<div class="bin-card ${cls}">
            <h3>Bin: ${r.bin_id}</h3>
            <p>Fill Level: ${r.fill_level}%</p>
            <p>Temperature: ${r.temp}°C</p>
            <p>Time: ${new Date(r.ts * 1000).toLocaleTimeString()}</p>
          </div>`;
        document.getElementById('bins').innerHTML += card;
        labels.push(new Date(r.ts * 1000).toLocaleTimeString());
        fills.push(r.fill_level);
        temps.push(r.temp);
      });
      drawChart(labels, fills, temps);
    }

    function drawChart(labels, fills, temps) {
      const ctx = document.getElementById('chart').getContext('2d');
      if (window.chartInstance) window.chartInstance.destroy();
      window.chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            { label: 'Fill Level (%)', data: fills, borderColor: 'green', fill: false },
            { label: 'Temperature (°C)', data: temps, borderColor: 'red', fill: false }
          ]
        },
        options: {
          scales: { y: { beginAtZero: true, max: 100 } }
        }
      });
    }

    setInterval(fetchData, 5000);
    fetchData();
  </script>
</body>
</html>
"""

@app.route("/")
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route("/api/latest")
def api_latest():
    return jsonify(fetch_latest())

def start_flask():
    app.run(host="0.0.0.0", port=5000, debug=False, use_reloader=False)

# ==========================================================
# MAIN EXECUTION
# ==========================================================
if __name__ == "__main__":
    init_db()

    # Run backend MQTT listener
    threading.Thread(target=start_mqtt_backend, daemon=True).start()

    # Run simulated IoT device
    threading.Thread(target=start_device_simulator, daemon=True).start()

    # Start dashboard
    start_flask()
